import { getTRPCErrorFromUnknown, isTrackedEnvelope, getTRPCErrorShape } from '@trpc/server';
import { observable, behaviorSubject } from '@trpc/server/observable';
import { TRPC_ERROR_CODES_BY_KEY } from '@trpc/server/rpc';
import { run, makeResource, isAsyncIterable, iteratorResource, isAbortError, retryableRpcCodes, callProcedure } from '@trpc/server/unstable-core-do-not-import';
import { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId.mjs';
import { raceAbortSignals, abortSignalToPromise } from '../internals/signals.mjs';
import { getTransformer } from '../internals/transformer.mjs';
import { isTRPCClientError, TRPCClientError } from '../TRPCClientError.mjs';

function _ts_add_disposable_resource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) {
        env.stack.push({
            async: true
        });
    }
    return value;
}
function _ts_dispose_resources(env) {
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    return (_ts_dispose_resources = function _ts_dispose_resources(env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    })(env);
}
/**
 * localLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.
 *
 * @see https://trpc.io/docs/links/localLink
 */ function experimental_localLink(opts) {
    const transformer = getTransformer(opts.transformer);
    const transformChunk = (chunk)=>{
        if (opts.transformer) {
            // assume transformer will do the right thing
            return chunk;
        }
        // Special case for undefined, because `JSON.stringify(undefined)` throws
        if (chunk === undefined) {
            return chunk;
        }
        const serialized = JSON.stringify(transformer.input.serialize(chunk));
        const deserialized = JSON.parse(transformer.output.deserialize(serialized));
        return deserialized;
    };
    return ()=>({ op })=>observable((observer)=>{
                let ctx = undefined;
                const ac = new AbortController();
                const signal = raceAbortSignals(op.signal, ac.signal);
                const signalPromise = abortSignalToPromise(signal);
                signalPromise.catch(()=>{
                // prevent unhandled rejection
                });
                let input = op.input;
                async function runProcedure(newInput) {
                    input = newInput;
                    ctx = await opts.createContext();
                    return callProcedure({
                        router: opts.router,
                        path: op.path,
                        getRawInput: async ()=>newInput,
                        ctx,
                        type: op.type,
                        signal
                    });
                }
                function onErrorCallback(cause) {
                    if (isAbortError(cause)) {
                        return;
                    }
                    opts.onError?.({
                        error: getTRPCErrorFromUnknown(cause),
                        type: op.type,
                        path: op.path,
                        input,
                        ctx
                    });
                }
                function coerceToTRPCClientError(cause) {
                    if (isTRPCClientError(cause)) {
                        return cause;
                    }
                    const error = getTRPCErrorFromUnknown(cause);
                    const shape = getTRPCErrorShape({
                        config: opts.router._def._config,
                        ctx,
                        error,
                        input,
                        path: op.path,
                        type: op.type
                    });
                    return TRPCClientError.from({
                        error: transformChunk(shape)
                    });
                }
                run(async ()=>{
                    switch(op.type){
                        case 'query':
                        case 'mutation':
                            {
                                const result = await runProcedure(op.input);
                                if (!isAsyncIterable(result)) {
                                    observer.next({
                                        result: {
                                            data: transformChunk(result)
                                        }
                                    });
                                    observer.complete();
                                    break;
                                }
                                observer.next({
                                    result: {
                                        data: async function*() {
                                            const env = {
                                                stack: [],
                                                error: void 0,
                                                hasError: false
                                            };
                                            try {
                                                const iterator = _ts_add_disposable_resource(env, iteratorResource(result), true);
                                                ;
                                                const _finally = _ts_add_disposable_resource(env, makeResource({}, ()=>{
                                                    observer.complete();
                                                }), false);
                                                ;
                                                try {
                                                    while(true){
                                                        const res = await Promise.race([
                                                            iterator.next(),
                                                            signalPromise
                                                        ]);
                                                        if (res.done) {
                                                            return transformChunk(res.value);
                                                        }
                                                        yield transformChunk(res.value);
                                                    }
                                                } catch (cause) {
                                                    onErrorCallback(cause);
                                                    throw coerceToTRPCClientError(cause);
                                                }
                                            } catch (e) {
                                                env.error = e;
                                                env.hasError = true;
                                            } finally{
                                                const result = _ts_dispose_resources(env);
                                                if (result) await result;
                                            }
                                        }()
                                    }
                                });
                                break;
                            }
                        case 'subscription':
                            {
                                const env = {
                                    stack: [],
                                    error: void 0,
                                    hasError: false
                                };
                                try {
                                    const connectionState = behaviorSubject({
                                        type: 'state',
                                        state: 'connecting',
                                        error: null
                                    });
                                    const connectionSub = connectionState.subscribe({
                                        next (state) {
                                            observer.next({
                                                result: state
                                            });
                                        }
                                    });
                                    let lastEventId = undefined;
                                    const _finally = _ts_add_disposable_resource(env, makeResource({}, async ()=>{
                                        observer.complete();
                                        connectionState.next({
                                            type: 'state',
                                            state: 'idle',
                                            error: null
                                        });
                                        connectionSub.unsubscribe();
                                    }), false);
                                    ;
                                    while(true){
                                        const env = {
                                            stack: [],
                                            error: void 0,
                                            hasError: false
                                        };
                                        try {
                                            const result = await runProcedure(inputWithTrackedEventId(op.input, lastEventId));
                                            if (!isAsyncIterable(result)) {
                                                throw new Error('Expected an async iterable');
                                            }
                                            const iterator = _ts_add_disposable_resource(env, iteratorResource(result), true);
                                            ;
                                            observer.next({
                                                result: {
                                                    type: 'started'
                                                }
                                            });
                                            connectionState.next({
                                                type: 'state',
                                                state: 'pending',
                                                error: null
                                            });
                                            // Use a while loop to handle errors and reconnects
                                            while(true){
                                                let res;
                                                try {
                                                    res = await Promise.race([
                                                        iterator.next(),
                                                        signalPromise
                                                    ]);
                                                } catch (cause) {
                                                    if (isAbortError(cause)) {
                                                        return;
                                                    }
                                                    const error = getTRPCErrorFromUnknown(cause);
                                                    if (!retryableRpcCodes.includes(TRPC_ERROR_CODES_BY_KEY[error.code])) {
                                                        throw coerceToTRPCClientError(error);
                                                    }
                                                    onErrorCallback(error);
                                                    connectionState.next({
                                                        type: 'state',
                                                        state: 'connecting',
                                                        error: coerceToTRPCClientError(error)
                                                    });
                                                    break;
                                                }
                                                if (res.done) {
                                                    return;
                                                }
                                                let chunk;
                                                if (isTrackedEnvelope(res.value)) {
                                                    lastEventId = res.value[0];
                                                    chunk = {
                                                        id: res.value[0],
                                                        data: {
                                                            id: res.value[0],
                                                            data: res.value[1]
                                                        }
                                                    };
                                                } else {
                                                    chunk = {
                                                        data: res.value
                                                    };
                                                }
                                                observer.next({
                                                    result: {
                                                        ...chunk,
                                                        data: transformChunk(chunk.data)
                                                    }
                                                });
                                            }
                                        } catch (e) {
                                            env.error = e;
                                            env.hasError = true;
                                        } finally{
                                            const result = _ts_dispose_resources(env);
                                            if (result) await result;
                                        }
                                    }
                                    break;
                                } catch (e) {
                                    env.error = e;
                                    env.hasError = true;
                                } finally{
                                    _ts_dispose_resources(env);
                                }
                            }
                    }
                }).catch((cause)=>{
                    onErrorCallback(cause);
                    observer.error(coerceToTRPCClientError(cause));
                });
                return ()=>{
                    ac.abort();
                };
            });
}

export { experimental_localLink };
